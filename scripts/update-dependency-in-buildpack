#!/usr/bin/env ruby
# encoding: utf-8

buildpacks_ci_dir = File.expand_path(File.join(File.dirname(__FILE__), '..'))
binary_builds_dir = File.expand_path(File.join(buildpacks_ci_dir, '..', 'built-out'))

require_relative "#{buildpacks_ci_dir}/lib/buildpack-dependency-updater"
require_relative "#{buildpacks_ci_dir}/lib/buildpack-dependency"
require_relative "#{buildpacks_ci_dir}/lib/tracker-client"
require_relative "#{buildpacks_ci_dir}/lib/git-client"

class BuildpackDoSomethingToItBecauseStuff
  def update_buildpack(binary_builds_dir, buildpacks_ci_dir)
    dependency = ENV['DEPENDENCY']

# can only handle one buildpack update atm
    buildpack = ENV.fetch("BUILDPACK_NAME", BuildpackDependency.for(dependency).first)
    buildpack_dir = File.expand_path(File.join(buildpacks_ci_dir, '..', "buildpack"))
    buildpack_updater = BuildpackDependencyUpdater.create(dependency, buildpack, buildpack_dir, binary_builds_dir)

    version = buildpack_updater.dependency_version

    puts "Updating manifest with #{dependency} #{version}..."
    buildpack_updater.run!
    return buildpack_dir, dependency, version
  end

  def write_git_commit(binary_builds_dir, buildpack_dir, dependency, story_ids, version)
    git_commit_message = GitClient.last_commit_message(binary_builds_dir)

    if git_commit_message.include?('gpg-signature:')
      /^(source url: .*END PGP SIGNATURE-----)/m.match(git_commit_message)
    else
      /^(source url: .*)$/.match(git_commit_message)
    end

    source_info = $1
    formatted_story_ids = story_ids.map {|story_id| "[##{story_id}]"}

    Dir.chdir(buildpack_dir) do
      raise 'command failed' unless system('git add -A')
      no_changes_present = system('git diff --cached --exit-code')
      unless no_changes_present
        raise 'command failed' unless system("git commit -m 'Update #{dependency} to #{version}\n\n#{source_info}\n\n#{formatted_story_ids.join("\n")}'")
      end
    end
  end

  def run!
    buildpack_dir, dependency, version = update_buildpack(binary_builds_dir, buildpacks_ci_dir)

    tracker_client = TrackerClient.new(ENV['TRACKER_API_TOKEN'], ENV['TRACKER_PROJECT_ID'], ENV['TRACKER_REQUESTER_ID'].to_i)
    story_ids = tracker_client.find_unaccepted_story_ids("include new #{dependency} #{version}")

    write_git_commit(binary_builds_dir, buildpack_dir, dependency, story_ids, version)
  end
end

BuildpackDoSomethingToItBecauseStuff.new.run!
