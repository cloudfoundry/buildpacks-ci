#!/usr/bin/env bash

set -euo pipefail

MY_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "${MY_DIR}/.." && pwd)"
OUTPUT_DIR="${REPO_ROOT}/tmp/pipeline-comparison"

usage() {
  cat <<EOF
Usage: ./bin/compare-pipelines [OPTIONS]

Generate and compare YTT vs ERB pipeline outputs without deploying.

Options:
  --pipeline=NAME, -p NAME    Compare specific pipeline
  --all                       Compare all buildpack pipelines
  --all-pipelines             Compare all pipelines (buildpacks + standard)
  --clean                     Remove comparison output directory
  --help, -h                  Show this help message

Examples:
  ./bin/compare-pipelines --pipeline=go-buildpack
  ./bin/compare-pipelines --pipeline=buildpack-verification
  ./bin/compare-pipelines --all
  ./bin/compare-pipelines --all-pipelines
  ./bin/compare-pipelines --clean

Output: ${OUTPUT_DIR}/
  Each pipeline will have:
    - <pipeline>-ytt.yml     (YTT generated)
    - <pipeline>-erb.yml     (ERB generated)
    - <pipeline>-diff.txt    (Differences)
EOF
}

get_ytt_buildpack_names() {
  local buildpack_dir="$REPO_ROOT/pipelines/buildpack"
  if [[ -d "$buildpack_dir" ]]; then
    for values_file in "$buildpack_dir"/*-values.yml; do
      if [[ -f "$values_file" ]]; then
        language="$(basename "${values_file%-values.yml}")"
        echo "${language}-buildpack"
      fi
    done
  fi
}

get_ytt_standard_pipeline_names() {
  # Returns standard pipelines that have both YTT and ERB versions
  local pipelines=()
  
  # Check for directory-based pipelines (excluding buildpack)
  for pipeline_path in "$REPO_ROOT"/pipelines/*; do
    if [[ ! -d "$pipeline_path" ]]; then
      continue
    fi
    
    local pipeline_name="$(basename "$pipeline_path")"
    
    # Skip special directories
    if [[ "$pipeline_name" == "config" || "$pipeline_name" == "templates" || "$pipeline_name" == "buildpack" ]]; then
      continue
    fi
    
    # Check if corresponding ERB template exists
    if [[ -f "$REPO_ROOT/pipelines/${pipeline_name}.yml.erb" ]]; then
      echo "$pipeline_name"
    fi
  done
}

generate_ytt_pipeline() {
  local pipeline_name="$1"
  
  # Check if this is a buildpack pipeline
  if [[ "$pipeline_name" == *-buildpack ]]; then
    local language="${pipeline_name%-buildpack}"
    local values_file="$REPO_ROOT/pipelines/buildpack/${language}-values.yml"
    
    if [[ ! -f "$values_file" ]]; then
      echo "ERROR: YTT values file not found: $values_file" >&2
      return 1
    fi
    
    ytt -f "$REPO_ROOT/pipelines/buildpack/pipeline.yml" \
        -f "$REPO_ROOT/pipelines/buildpack/config.yml" \
        -f "$values_file"
  else
    # Standard pipeline in its own directory
    local pipeline_dir="$REPO_ROOT/pipelines/$pipeline_name"
    
    if [[ ! -d "$pipeline_dir" ]]; then
      echo "ERROR: YTT pipeline directory not found: $pipeline_dir" >&2
      return 1
    fi
    
    ytt -f "$pipeline_dir"
  fi
}

generate_erb_pipeline() {
  local pipeline_name="$1"
  
  # Check if this is a buildpack pipeline
  if [[ "$pipeline_name" == *-buildpack ]]; then
    local language="${pipeline_name%-buildpack}"
    local config_file="$REPO_ROOT/config/buildpack/${language}.yml"
    local template_file="$REPO_ROOT/pipelines/templates/buildpack.yml.erb"
    
    if [[ ! -f "$config_file" ]]; then
      echo "ERROR: ERB config file not found: $config_file" >&2
      return 1
    fi
    
    if [[ ! -f "$template_file" ]]; then
      echo "ERROR: ERB template file not found: $template_file" >&2
      return 1
    fi
    
    # Use ERB to generate the pipeline (mimics update-erb-pipelines logic)
    LANGUAGE="$language" CONFIG_FILE="$config_file" TEMPLATE_FILE="$template_file" \
      ruby -I"$REPO_ROOT/lib" -e '
require "yaml"
require "erb"
require "buildpacks-ci-configuration"

language = ENV["LANGUAGE"]
config_file = ENV["CONFIG_FILE"]
template_file = ENV["TEMPLATE_FILE"]

# Get organization from configuration
config = BuildpacksCIConfiguration.new
organization = config.organization

# Run ERB with language and organization variables
system("erb", "language=#{language}", "organization=#{organization}", template_file)
' 2>&1
  else
    # Standard pipeline ERB template
    local template_file="$REPO_ROOT/pipelines/${pipeline_name}.yml.erb"
    
    if [[ ! -f "$template_file" ]]; then
      echo "ERROR: ERB template file not found: $template_file" >&2
      return 1
    fi
    
    # Generate using ERB with organization variable
    TEMPLATE_FILE="$template_file" \
      ruby -I"$REPO_ROOT/lib" -e '
require "yaml"
require "erb"
require "buildpacks-ci-configuration"

template_file = ENV["TEMPLATE_FILE"]

# Get organization from configuration
config = BuildpacksCIConfiguration.new
organization = config.organization

# Run ERB with organization variable
system("erb", "organization=#{organization}", template_file)
' 2>&1
  fi
}

compare_pipeline() {
  local buildpack_name="$1"
  local ytt_file="$OUTPUT_DIR/${buildpack_name}-ytt.yml"
  local erb_file="$OUTPUT_DIR/${buildpack_name}-erb.yml"
  local ytt_normalized="$OUTPUT_DIR/${buildpack_name}-ytt-normalized.yml"
  local erb_normalized="$OUTPUT_DIR/${buildpack_name}-erb-normalized.yml"
  local diff_file="$OUTPUT_DIR/${buildpack_name}-diff.txt"
  local diff_normalized_file="$OUTPUT_DIR/${buildpack_name}-diff-normalized.txt"
  
  echo "Comparing $buildpack_name..."
  
  # Generate YTT version
  if ! generate_ytt_pipeline "$buildpack_name" > "$ytt_file" 2>&1; then
    echo "  ERROR: Failed to generate YTT pipeline"
    cat "$ytt_file"
    return 1
  fi
  
  # Generate ERB version
  if ! generate_erb_pipeline "$buildpack_name" > "$erb_file" 2>&1; then
    echo "  ERROR: Failed to generate ERB pipeline"
    cat "$erb_file"
    return 1
  fi
  
  # Interpolate Concourse variables in ERB output (mimics what fly --load-vars-from does)
  local erb_interpolated="$OUTPUT_DIR/${buildpack_name}-erb-interpolated.yml"
  "$MY_DIR/interpolate-concourse-vars" < "$erb_file" > "$erb_interpolated"
  
  # Normalize both files for semantic comparison
  "$MY_DIR/normalize-yaml" < "$ytt_file" > "$ytt_normalized" 2>&1
  "$MY_DIR/normalize-yaml" < "$erb_interpolated" > "$erb_normalized" 2>&1
  
  # Compare raw files first (use interpolated ERB)
  if diff -u "$erb_interpolated" "$ytt_file" > "$diff_file" 2>&1; then
    echo "  ✓ IDENTICAL (raw) - No differences found"
    rm "$diff_file" "$ytt_normalized" "$erb_normalized"
    return 0
  fi
  
  # Compare normalized files for semantic differences
  if diff -u "$erb_normalized" "$ytt_normalized" > "$diff_normalized_file" 2>&1; then
    echo "  ✓ IDENTICAL (semantic) - Only formatting differences"
    echo "    Raw diff lines: $(wc -l < "$diff_file")"
    rm "$diff_normalized_file"
    return 0
  else
    echo "  ✗ SEMANTIC DIFFERENCES FOUND"
    echo "    Raw diff: $diff_file ($(wc -l < "$diff_file") lines)"
    echo "    Semantic diff: $diff_normalized_file ($(wc -l < "$diff_normalized_file") lines)"
    return 1
  fi
}

main() {
  local pipeline_filter=""
  local compare_all=false
  local compare_all_pipelines=false
  local clean_mode=false
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --pipeline=*)
        pipeline_filter="${1#*=}"
        shift
        ;;
      --pipeline|-p)
        pipeline_filter="$2"
        shift 2
        ;;
      --all)
        compare_all=true
        shift
        ;;
      --all-pipelines)
        compare_all_pipelines=true
        shift
        ;;
      --clean)
        clean_mode=true
        shift
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        usage
        exit 1
        ;;
    esac
  done
  
  # Clean mode
  if [[ "$clean_mode" == true ]]; then
    if [[ -d "$OUTPUT_DIR" ]]; then
      echo "Removing $OUTPUT_DIR"
      rm -rf "$OUTPUT_DIR"
      echo "Done."
    else
      echo "Nothing to clean - $OUTPUT_DIR does not exist"
    fi
    exit 0
  fi
  
  # Ensure output directory exists
  mkdir -p "$OUTPUT_DIR"
  
  # Get list of pipelines to compare
  local pipelines_to_compare=()
  
  if [[ -n "$pipeline_filter" ]]; then
    # Compare specific pipeline
    pipelines_to_compare=("$pipeline_filter")
  elif [[ "$compare_all" == true ]]; then
    # Compare all buildpack pipelines
    pipelines_to_compare=($(get_ytt_buildpack_names))
  elif [[ "$compare_all_pipelines" == true ]]; then
    # Compare all pipelines (buildpacks + standard)
    pipelines_to_compare=($(get_ytt_buildpack_names) $(get_ytt_standard_pipeline_names))
  else
    echo "ERROR: Must specify --pipeline=NAME, --all, or --all-pipelines"
    usage
    exit 1
  fi
  
  if [[ "${#pipelines_to_compare[@]}" -eq 0 ]]; then
    echo "ERROR: No pipelines found to compare"
    exit 1
  fi
  
  # Compare pipelines
  local success_count=0
  local failure_count=0
  
  if [[ "${#pipelines_to_compare[@]}" -gt 1 ]]; then
    echo "Comparing ${#pipelines_to_compare[@]} pipelines..."
    echo ""
  fi
  
  for pipeline in "${pipelines_to_compare[@]}"; do
    if compare_pipeline "$pipeline"; then
      ((success_count++)) || true
    else
      ((failure_count++)) || true
    fi
  done
  
  # Summary
  echo ""
  echo "=========================================="
  echo "Comparison Summary"
  echo "=========================================="
  echo "Identical:   $success_count"
  echo "Differences: $failure_count"
  echo ""
  echo "Output directory: $OUTPUT_DIR"
  
  if [[ $failure_count -gt 0 ]]; then
    exit 1
  fi
}

main "$@"
