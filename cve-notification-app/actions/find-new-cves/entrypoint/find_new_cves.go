package main

import (
	"encoding/json"
	"fmt"
	"github.com/jessevdk/go-flags"
	"github.com/rs/zerolog"
	"os"
	"time"

	"github.com/cloudfoundry/buildpacks-ci/cve-notification-app/utils"
	"github.com/spf13/afero"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type AllUtils struct {
	MongoUtils   utils.MongoUtilsInterface
	NVDNistUtils utils.NVDNistUtilsInterface
	SlackUtils   utils.SlackUtilsInterface
	FileSystem   afero.Fs
}

func main() {

	var opts struct {
		DBUri            string `long:"db-uri" description:"Database URI" required:"true"`
		SlackWebhookUrl  string `long:"webhook-url" description:"Slack webhook URL" required:"true"`
		CVESJsonFilepath string `long:"json-filepath" description:"CVEs JSON output Filepath" required:"true"`
		LogFilepath      string `long:"log-filepath" description:"Log output Filepath" required:"true"`
		NVDNistApiKey    string `long:"nvd-nist-api-key" description:"NVD Nist API Key" required:"true"`
	}

	_, err := flags.Parse(&opts)
	if err != nil {
		os.Exit(1)
	}

	logFile, err := os.OpenFile(opts.LogFilepath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	logger := zerolog.New(logFile).With().Timestamp().Logger()

	allUtils := AllUtils{
		MongoUtils:   utils.NewMongoUtils(opts.DBUri, logger),
		NVDNistUtils: utils.NewNVDNistUtils(opts.NVDNistApiKey),
		SlackUtils:   utils.NewSlackUtils(opts.SlackWebhookUrl),
		FileSystem:   afero.NewOsFs(),
	}

	newCves, err := FindNewCVEs(allUtils, opts.CVESJsonFilepath, logger)
	if err != nil {
		logger.Warn().Err(err).Msg("Error finding new CVEs")
	}

	if newCves {
		logger.Info().Msg("New CVEs found")
	} else {
		logger.Info().Msg("No new CVEs found")
	}

}

func FindNewCVEs(allUtils AllUtils, jsonFilepath string, logger zerolog.Logger) (bool, error) {

	newCves := false

	mongoClient, ctx, err := allUtils.MongoUtils.GetMongoClient()
	if err != nil {
		return false, err
	}

	collection := allUtils.MongoUtils.GetMongoCollection(*mongoClient, "buildpacks", "cves")

	trackedDependencies, err := allUtils.MongoUtils.GetUniqueDependencies(ctx, collection)
	if err != nil {
		return false, err
	}

	for _, trackedDep := range trackedDependencies {
		logger.Info().Msgf("Getting CVEs for %s/%s", trackedDep.Vendor, trackedDep.Product)
		cves, err := allUtils.NVDNistUtils.GetCVEs(trackedDep.Vendor, trackedDep.Product, logger)
		if err != nil {
			logger.Warn().Err(err).Msgf("Error getting CVEs for %s/%s", trackedDep.Vendor, trackedDep.Product)
			continue
		}

		for _, cveItem := range cves {
			exists, err := allUtils.MongoUtils.CVEExists(cveItem.CVE.Id, ctx, collection)
			if err != nil {
				logger.Warn().Err(err).Msgf("Error checking if CVE %s exists", cveItem.CVE.Id)
				continue
			}

			if !exists {
				cveSeverity, cveScore := getCVESeverity(cveItem.CVE)

				cveDescription := getCVEDescription(cveItem.CVE)

				cve := utils.CVE{
					ID:          primitive.NewObjectID(),
					CreatedAt:   time.Now(),
					UpdatedAt:   time.Now(),
					Vendor:      trackedDep.Vendor,
					Product:     trackedDep.Product,
					Severity:    cveSeverity,
					Score:       cveScore,
					CVEId:       cveItem.CVE.Id,
					Description: cveDescription,
				}

				logger.Info().Msgf("New CVE found: %s", cve.CVEId)

				err = allUtils.MongoUtils.CreateCVE(&cve, ctx, collection)
				if err != nil {
					logger.Warn().Err(err).Msgf("Error creating CVE %s", cve.CVEId)
					continue
				}

				err = allUtils.SlackUtils.SendNewCVENotification(cve.Product, cve.CVEId, cve.Description, cve.Severity, cve.Score)
				if err != nil {
					logger.Warn().Err(err).Msgf("Error sending Slack notification for CVE %s", cve.CVEId)
					continue
				}

				newCves = true
			}
		}

		time.Sleep(2 * time.Second)
	}

	err = allUtils.MongoUtils.DisconnectMongoClient(mongoClient, ctx)
	if err != nil {
		return false, err
	}

	if newCves {
		err = generateJSONFile(allUtils, jsonFilepath)
		if err != nil {
			return false, err
		}
	}

	return newCves, nil
}

func getCVEDescription(cve utils.NVDNistResponseCVE) string {
	description := "No description available"
	for _, desc := range cve.Descriptions {
		if desc.Lang == "en" {
			description = desc.Value
		}
	}

	return description
}

func getCVESeverity(cve utils.NVDNistResponseCVE) (string, float64) {
	cveSeverity := "Unknown"
	cveScore := 0.0
	if cve.Metrics.CvssMetricV3 != nil {
		cveSeverity = cve.Metrics.CvssMetricV3[0].CvssData.BaseSeverity
		cveScore = cve.Metrics.CvssMetricV3[0].CvssData.BaseScore
	} else if cve.Metrics.CvssMetricV2 != nil {
		cveSeverity = cve.Metrics.CvssMetricV2[0].CvssData.BaseSeverity
		cveScore = cve.Metrics.CvssMetricV2[0].CvssData.BaseScore
	}

	return cveSeverity, cveScore
}

func generateJSONFile(allUtils AllUtils, jsonFilepath string) error {

	result := make(map[string][]utils.CVE)

	mongoClient, ctx, err := allUtils.MongoUtils.GetMongoClient()
	if err != nil {
		return err
	}

	collection := allUtils.MongoUtils.GetMongoCollection(*mongoClient, "buildpacks", "cves")

	cves, err := allUtils.MongoUtils.GetAllCVEs(ctx, collection)
	if err != nil {
		return err
	}

	for _, cve := range cves {
		result[cve.Product] = append(result[cve.Product], cve)
	}

	err = allUtils.MongoUtils.DisconnectMongoClient(mongoClient, ctx)
	if err != nil {
		return err
	}

	jsonBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("error marshaling json object\n%w", err)
	}

	err = afero.WriteFile(allUtils.FileSystem, jsonFilepath, jsonBytes, 0644)
	if err != nil {
		return fmt.Errorf("error creating cves.json file\n%w", err)
	}

	return nil
}
