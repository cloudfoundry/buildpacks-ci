// Code generated by counterfeiter. DO NOT EDIT.
package utilsfakes

import (
	"context"
	"sync"

	"github.com/cloudfoundry/buildpacks-ci/cve-notification-app/utils"
	"go.mongodb.org/mongo-driver/mongo"
)

type FakeMongoUtilsInterface struct {
	CVEExistsStub        func(string, context.Context, *mongo.Collection) (bool, error)
	cVEExistsMutex       sync.RWMutex
	cVEExistsArgsForCall []struct {
		arg1 string
		arg2 context.Context
		arg3 *mongo.Collection
	}
	cVEExistsReturns struct {
		result1 bool
		result2 error
	}
	cVEExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateCVEStub        func(*utils.CVE, context.Context, *mongo.Collection) error
	createCVEMutex       sync.RWMutex
	createCVEArgsForCall []struct {
		arg1 *utils.CVE
		arg2 context.Context
		arg3 *mongo.Collection
	}
	createCVEReturns struct {
		result1 error
	}
	createCVEReturnsOnCall map[int]struct {
		result1 error
	}
	DisconnectMongoClientStub        func(*mongo.Client, context.Context) error
	disconnectMongoClientMutex       sync.RWMutex
	disconnectMongoClientArgsForCall []struct {
		arg1 *mongo.Client
		arg2 context.Context
	}
	disconnectMongoClientReturns struct {
		result1 error
	}
	disconnectMongoClientReturnsOnCall map[int]struct {
		result1 error
	}
	FindCVEStub        func(string, context.Context, *mongo.Collection) (utils.CVE, error)
	findCVEMutex       sync.RWMutex
	findCVEArgsForCall []struct {
		arg1 string
		arg2 context.Context
		arg3 *mongo.Collection
	}
	findCVEReturns struct {
		result1 utils.CVE
		result2 error
	}
	findCVEReturnsOnCall map[int]struct {
		result1 utils.CVE
		result2 error
	}
	GetAllCVEsStub        func(context.Context, *mongo.Collection) ([]utils.CVE, error)
	getAllCVEsMutex       sync.RWMutex
	getAllCVEsArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Collection
	}
	getAllCVEsReturns struct {
		result1 []utils.CVE
		result2 error
	}
	getAllCVEsReturnsOnCall map[int]struct {
		result1 []utils.CVE
		result2 error
	}
	GetMongoClientStub        func() (*mongo.Client, context.Context, error)
	getMongoClientMutex       sync.RWMutex
	getMongoClientArgsForCall []struct {
	}
	getMongoClientReturns struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}
	getMongoClientReturnsOnCall map[int]struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}
	GetMongoCollectionStub        func(mongo.Client, string, string) *mongo.Collection
	getMongoCollectionMutex       sync.RWMutex
	getMongoCollectionArgsForCall []struct {
		arg1 mongo.Client
		arg2 string
		arg3 string
	}
	getMongoCollectionReturns struct {
		result1 *mongo.Collection
	}
	getMongoCollectionReturnsOnCall map[int]struct {
		result1 *mongo.Collection
	}
	GetUniqueDependenciesStub        func(context.Context, *mongo.Collection) ([]utils.CVE, error)
	getUniqueDependenciesMutex       sync.RWMutex
	getUniqueDependenciesArgsForCall []struct {
		arg1 context.Context
		arg2 *mongo.Collection
	}
	getUniqueDependenciesReturns struct {
		result1 []utils.CVE
		result2 error
	}
	getUniqueDependenciesReturnsOnCall map[int]struct {
		result1 []utils.CVE
		result2 error
	}
	RemoveAllCVEsStub        func(string, context.Context, *mongo.Collection) error
	removeAllCVEsMutex       sync.RWMutex
	removeAllCVEsArgsForCall []struct {
		arg1 string
		arg2 context.Context
		arg3 *mongo.Collection
	}
	removeAllCVEsReturns struct {
		result1 error
	}
	removeAllCVEsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMongoUtilsInterface) CVEExists(arg1 string, arg2 context.Context, arg3 *mongo.Collection) (bool, error) {
	fake.cVEExistsMutex.Lock()
	ret, specificReturn := fake.cVEExistsReturnsOnCall[len(fake.cVEExistsArgsForCall)]
	fake.cVEExistsArgsForCall = append(fake.cVEExistsArgsForCall, struct {
		arg1 string
		arg2 context.Context
		arg3 *mongo.Collection
	}{arg1, arg2, arg3})
	stub := fake.CVEExistsStub
	fakeReturns := fake.cVEExistsReturns
	fake.recordInvocation("CVEExists", []interface{}{arg1, arg2, arg3})
	fake.cVEExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoUtilsInterface) CVEExistsCallCount() int {
	fake.cVEExistsMutex.RLock()
	defer fake.cVEExistsMutex.RUnlock()
	return len(fake.cVEExistsArgsForCall)
}

func (fake *FakeMongoUtilsInterface) CVEExistsCalls(stub func(string, context.Context, *mongo.Collection) (bool, error)) {
	fake.cVEExistsMutex.Lock()
	defer fake.cVEExistsMutex.Unlock()
	fake.CVEExistsStub = stub
}

func (fake *FakeMongoUtilsInterface) CVEExistsArgsForCall(i int) (string, context.Context, *mongo.Collection) {
	fake.cVEExistsMutex.RLock()
	defer fake.cVEExistsMutex.RUnlock()
	argsForCall := fake.cVEExistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoUtilsInterface) CVEExistsReturns(result1 bool, result2 error) {
	fake.cVEExistsMutex.Lock()
	defer fake.cVEExistsMutex.Unlock()
	fake.CVEExistsStub = nil
	fake.cVEExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) CVEExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.cVEExistsMutex.Lock()
	defer fake.cVEExistsMutex.Unlock()
	fake.CVEExistsStub = nil
	if fake.cVEExistsReturnsOnCall == nil {
		fake.cVEExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.cVEExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) CreateCVE(arg1 *utils.CVE, arg2 context.Context, arg3 *mongo.Collection) error {
	fake.createCVEMutex.Lock()
	ret, specificReturn := fake.createCVEReturnsOnCall[len(fake.createCVEArgsForCall)]
	fake.createCVEArgsForCall = append(fake.createCVEArgsForCall, struct {
		arg1 *utils.CVE
		arg2 context.Context
		arg3 *mongo.Collection
	}{arg1, arg2, arg3})
	stub := fake.CreateCVEStub
	fakeReturns := fake.createCVEReturns
	fake.recordInvocation("CreateCVE", []interface{}{arg1, arg2, arg3})
	fake.createCVEMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoUtilsInterface) CreateCVECallCount() int {
	fake.createCVEMutex.RLock()
	defer fake.createCVEMutex.RUnlock()
	return len(fake.createCVEArgsForCall)
}

func (fake *FakeMongoUtilsInterface) CreateCVECalls(stub func(*utils.CVE, context.Context, *mongo.Collection) error) {
	fake.createCVEMutex.Lock()
	defer fake.createCVEMutex.Unlock()
	fake.CreateCVEStub = stub
}

func (fake *FakeMongoUtilsInterface) CreateCVEArgsForCall(i int) (*utils.CVE, context.Context, *mongo.Collection) {
	fake.createCVEMutex.RLock()
	defer fake.createCVEMutex.RUnlock()
	argsForCall := fake.createCVEArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoUtilsInterface) CreateCVEReturns(result1 error) {
	fake.createCVEMutex.Lock()
	defer fake.createCVEMutex.Unlock()
	fake.CreateCVEStub = nil
	fake.createCVEReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoUtilsInterface) CreateCVEReturnsOnCall(i int, result1 error) {
	fake.createCVEMutex.Lock()
	defer fake.createCVEMutex.Unlock()
	fake.CreateCVEStub = nil
	if fake.createCVEReturnsOnCall == nil {
		fake.createCVEReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createCVEReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoUtilsInterface) DisconnectMongoClient(arg1 *mongo.Client, arg2 context.Context) error {
	fake.disconnectMongoClientMutex.Lock()
	ret, specificReturn := fake.disconnectMongoClientReturnsOnCall[len(fake.disconnectMongoClientArgsForCall)]
	fake.disconnectMongoClientArgsForCall = append(fake.disconnectMongoClientArgsForCall, struct {
		arg1 *mongo.Client
		arg2 context.Context
	}{arg1, arg2})
	stub := fake.DisconnectMongoClientStub
	fakeReturns := fake.disconnectMongoClientReturns
	fake.recordInvocation("DisconnectMongoClient", []interface{}{arg1, arg2})
	fake.disconnectMongoClientMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoUtilsInterface) DisconnectMongoClientCallCount() int {
	fake.disconnectMongoClientMutex.RLock()
	defer fake.disconnectMongoClientMutex.RUnlock()
	return len(fake.disconnectMongoClientArgsForCall)
}

func (fake *FakeMongoUtilsInterface) DisconnectMongoClientCalls(stub func(*mongo.Client, context.Context) error) {
	fake.disconnectMongoClientMutex.Lock()
	defer fake.disconnectMongoClientMutex.Unlock()
	fake.DisconnectMongoClientStub = stub
}

func (fake *FakeMongoUtilsInterface) DisconnectMongoClientArgsForCall(i int) (*mongo.Client, context.Context) {
	fake.disconnectMongoClientMutex.RLock()
	defer fake.disconnectMongoClientMutex.RUnlock()
	argsForCall := fake.disconnectMongoClientArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoUtilsInterface) DisconnectMongoClientReturns(result1 error) {
	fake.disconnectMongoClientMutex.Lock()
	defer fake.disconnectMongoClientMutex.Unlock()
	fake.DisconnectMongoClientStub = nil
	fake.disconnectMongoClientReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoUtilsInterface) DisconnectMongoClientReturnsOnCall(i int, result1 error) {
	fake.disconnectMongoClientMutex.Lock()
	defer fake.disconnectMongoClientMutex.Unlock()
	fake.DisconnectMongoClientStub = nil
	if fake.disconnectMongoClientReturnsOnCall == nil {
		fake.disconnectMongoClientReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disconnectMongoClientReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoUtilsInterface) FindCVE(arg1 string, arg2 context.Context, arg3 *mongo.Collection) (utils.CVE, error) {
	fake.findCVEMutex.Lock()
	ret, specificReturn := fake.findCVEReturnsOnCall[len(fake.findCVEArgsForCall)]
	fake.findCVEArgsForCall = append(fake.findCVEArgsForCall, struct {
		arg1 string
		arg2 context.Context
		arg3 *mongo.Collection
	}{arg1, arg2, arg3})
	stub := fake.FindCVEStub
	fakeReturns := fake.findCVEReturns
	fake.recordInvocation("FindCVE", []interface{}{arg1, arg2, arg3})
	fake.findCVEMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoUtilsInterface) FindCVECallCount() int {
	fake.findCVEMutex.RLock()
	defer fake.findCVEMutex.RUnlock()
	return len(fake.findCVEArgsForCall)
}

func (fake *FakeMongoUtilsInterface) FindCVECalls(stub func(string, context.Context, *mongo.Collection) (utils.CVE, error)) {
	fake.findCVEMutex.Lock()
	defer fake.findCVEMutex.Unlock()
	fake.FindCVEStub = stub
}

func (fake *FakeMongoUtilsInterface) FindCVEArgsForCall(i int) (string, context.Context, *mongo.Collection) {
	fake.findCVEMutex.RLock()
	defer fake.findCVEMutex.RUnlock()
	argsForCall := fake.findCVEArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoUtilsInterface) FindCVEReturns(result1 utils.CVE, result2 error) {
	fake.findCVEMutex.Lock()
	defer fake.findCVEMutex.Unlock()
	fake.FindCVEStub = nil
	fake.findCVEReturns = struct {
		result1 utils.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) FindCVEReturnsOnCall(i int, result1 utils.CVE, result2 error) {
	fake.findCVEMutex.Lock()
	defer fake.findCVEMutex.Unlock()
	fake.FindCVEStub = nil
	if fake.findCVEReturnsOnCall == nil {
		fake.findCVEReturnsOnCall = make(map[int]struct {
			result1 utils.CVE
			result2 error
		})
	}
	fake.findCVEReturnsOnCall[i] = struct {
		result1 utils.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) GetAllCVEs(arg1 context.Context, arg2 *mongo.Collection) ([]utils.CVE, error) {
	fake.getAllCVEsMutex.Lock()
	ret, specificReturn := fake.getAllCVEsReturnsOnCall[len(fake.getAllCVEsArgsForCall)]
	fake.getAllCVEsArgsForCall = append(fake.getAllCVEsArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Collection
	}{arg1, arg2})
	stub := fake.GetAllCVEsStub
	fakeReturns := fake.getAllCVEsReturns
	fake.recordInvocation("GetAllCVEs", []interface{}{arg1, arg2})
	fake.getAllCVEsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoUtilsInterface) GetAllCVEsCallCount() int {
	fake.getAllCVEsMutex.RLock()
	defer fake.getAllCVEsMutex.RUnlock()
	return len(fake.getAllCVEsArgsForCall)
}

func (fake *FakeMongoUtilsInterface) GetAllCVEsCalls(stub func(context.Context, *mongo.Collection) ([]utils.CVE, error)) {
	fake.getAllCVEsMutex.Lock()
	defer fake.getAllCVEsMutex.Unlock()
	fake.GetAllCVEsStub = stub
}

func (fake *FakeMongoUtilsInterface) GetAllCVEsArgsForCall(i int) (context.Context, *mongo.Collection) {
	fake.getAllCVEsMutex.RLock()
	defer fake.getAllCVEsMutex.RUnlock()
	argsForCall := fake.getAllCVEsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoUtilsInterface) GetAllCVEsReturns(result1 []utils.CVE, result2 error) {
	fake.getAllCVEsMutex.Lock()
	defer fake.getAllCVEsMutex.Unlock()
	fake.GetAllCVEsStub = nil
	fake.getAllCVEsReturns = struct {
		result1 []utils.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) GetAllCVEsReturnsOnCall(i int, result1 []utils.CVE, result2 error) {
	fake.getAllCVEsMutex.Lock()
	defer fake.getAllCVEsMutex.Unlock()
	fake.GetAllCVEsStub = nil
	if fake.getAllCVEsReturnsOnCall == nil {
		fake.getAllCVEsReturnsOnCall = make(map[int]struct {
			result1 []utils.CVE
			result2 error
		})
	}
	fake.getAllCVEsReturnsOnCall[i] = struct {
		result1 []utils.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) GetMongoClient() (*mongo.Client, context.Context, error) {
	fake.getMongoClientMutex.Lock()
	ret, specificReturn := fake.getMongoClientReturnsOnCall[len(fake.getMongoClientArgsForCall)]
	fake.getMongoClientArgsForCall = append(fake.getMongoClientArgsForCall, struct {
	}{})
	stub := fake.GetMongoClientStub
	fakeReturns := fake.getMongoClientReturns
	fake.recordInvocation("GetMongoClient", []interface{}{})
	fake.getMongoClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeMongoUtilsInterface) GetMongoClientCallCount() int {
	fake.getMongoClientMutex.RLock()
	defer fake.getMongoClientMutex.RUnlock()
	return len(fake.getMongoClientArgsForCall)
}

func (fake *FakeMongoUtilsInterface) GetMongoClientCalls(stub func() (*mongo.Client, context.Context, error)) {
	fake.getMongoClientMutex.Lock()
	defer fake.getMongoClientMutex.Unlock()
	fake.GetMongoClientStub = stub
}

func (fake *FakeMongoUtilsInterface) GetMongoClientReturns(result1 *mongo.Client, result2 context.Context, result3 error) {
	fake.getMongoClientMutex.Lock()
	defer fake.getMongoClientMutex.Unlock()
	fake.GetMongoClientStub = nil
	fake.getMongoClientReturns = struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMongoUtilsInterface) GetMongoClientReturnsOnCall(i int, result1 *mongo.Client, result2 context.Context, result3 error) {
	fake.getMongoClientMutex.Lock()
	defer fake.getMongoClientMutex.Unlock()
	fake.GetMongoClientStub = nil
	if fake.getMongoClientReturnsOnCall == nil {
		fake.getMongoClientReturnsOnCall = make(map[int]struct {
			result1 *mongo.Client
			result2 context.Context
			result3 error
		})
	}
	fake.getMongoClientReturnsOnCall[i] = struct {
		result1 *mongo.Client
		result2 context.Context
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeMongoUtilsInterface) GetMongoCollection(arg1 mongo.Client, arg2 string, arg3 string) *mongo.Collection {
	fake.getMongoCollectionMutex.Lock()
	ret, specificReturn := fake.getMongoCollectionReturnsOnCall[len(fake.getMongoCollectionArgsForCall)]
	fake.getMongoCollectionArgsForCall = append(fake.getMongoCollectionArgsForCall, struct {
		arg1 mongo.Client
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetMongoCollectionStub
	fakeReturns := fake.getMongoCollectionReturns
	fake.recordInvocation("GetMongoCollection", []interface{}{arg1, arg2, arg3})
	fake.getMongoCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoUtilsInterface) GetMongoCollectionCallCount() int {
	fake.getMongoCollectionMutex.RLock()
	defer fake.getMongoCollectionMutex.RUnlock()
	return len(fake.getMongoCollectionArgsForCall)
}

func (fake *FakeMongoUtilsInterface) GetMongoCollectionCalls(stub func(mongo.Client, string, string) *mongo.Collection) {
	fake.getMongoCollectionMutex.Lock()
	defer fake.getMongoCollectionMutex.Unlock()
	fake.GetMongoCollectionStub = stub
}

func (fake *FakeMongoUtilsInterface) GetMongoCollectionArgsForCall(i int) (mongo.Client, string, string) {
	fake.getMongoCollectionMutex.RLock()
	defer fake.getMongoCollectionMutex.RUnlock()
	argsForCall := fake.getMongoCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoUtilsInterface) GetMongoCollectionReturns(result1 *mongo.Collection) {
	fake.getMongoCollectionMutex.Lock()
	defer fake.getMongoCollectionMutex.Unlock()
	fake.GetMongoCollectionStub = nil
	fake.getMongoCollectionReturns = struct {
		result1 *mongo.Collection
	}{result1}
}

func (fake *FakeMongoUtilsInterface) GetMongoCollectionReturnsOnCall(i int, result1 *mongo.Collection) {
	fake.getMongoCollectionMutex.Lock()
	defer fake.getMongoCollectionMutex.Unlock()
	fake.GetMongoCollectionStub = nil
	if fake.getMongoCollectionReturnsOnCall == nil {
		fake.getMongoCollectionReturnsOnCall = make(map[int]struct {
			result1 *mongo.Collection
		})
	}
	fake.getMongoCollectionReturnsOnCall[i] = struct {
		result1 *mongo.Collection
	}{result1}
}

func (fake *FakeMongoUtilsInterface) GetUniqueDependencies(arg1 context.Context, arg2 *mongo.Collection) ([]utils.CVE, error) {
	fake.getUniqueDependenciesMutex.Lock()
	ret, specificReturn := fake.getUniqueDependenciesReturnsOnCall[len(fake.getUniqueDependenciesArgsForCall)]
	fake.getUniqueDependenciesArgsForCall = append(fake.getUniqueDependenciesArgsForCall, struct {
		arg1 context.Context
		arg2 *mongo.Collection
	}{arg1, arg2})
	stub := fake.GetUniqueDependenciesStub
	fakeReturns := fake.getUniqueDependenciesReturns
	fake.recordInvocation("GetUniqueDependencies", []interface{}{arg1, arg2})
	fake.getUniqueDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMongoUtilsInterface) GetUniqueDependenciesCallCount() int {
	fake.getUniqueDependenciesMutex.RLock()
	defer fake.getUniqueDependenciesMutex.RUnlock()
	return len(fake.getUniqueDependenciesArgsForCall)
}

func (fake *FakeMongoUtilsInterface) GetUniqueDependenciesCalls(stub func(context.Context, *mongo.Collection) ([]utils.CVE, error)) {
	fake.getUniqueDependenciesMutex.Lock()
	defer fake.getUniqueDependenciesMutex.Unlock()
	fake.GetUniqueDependenciesStub = stub
}

func (fake *FakeMongoUtilsInterface) GetUniqueDependenciesArgsForCall(i int) (context.Context, *mongo.Collection) {
	fake.getUniqueDependenciesMutex.RLock()
	defer fake.getUniqueDependenciesMutex.RUnlock()
	argsForCall := fake.getUniqueDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMongoUtilsInterface) GetUniqueDependenciesReturns(result1 []utils.CVE, result2 error) {
	fake.getUniqueDependenciesMutex.Lock()
	defer fake.getUniqueDependenciesMutex.Unlock()
	fake.GetUniqueDependenciesStub = nil
	fake.getUniqueDependenciesReturns = struct {
		result1 []utils.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) GetUniqueDependenciesReturnsOnCall(i int, result1 []utils.CVE, result2 error) {
	fake.getUniqueDependenciesMutex.Lock()
	defer fake.getUniqueDependenciesMutex.Unlock()
	fake.GetUniqueDependenciesStub = nil
	if fake.getUniqueDependenciesReturnsOnCall == nil {
		fake.getUniqueDependenciesReturnsOnCall = make(map[int]struct {
			result1 []utils.CVE
			result2 error
		})
	}
	fake.getUniqueDependenciesReturnsOnCall[i] = struct {
		result1 []utils.CVE
		result2 error
	}{result1, result2}
}

func (fake *FakeMongoUtilsInterface) RemoveAllCVEs(arg1 string, arg2 context.Context, arg3 *mongo.Collection) error {
	fake.removeAllCVEsMutex.Lock()
	ret, specificReturn := fake.removeAllCVEsReturnsOnCall[len(fake.removeAllCVEsArgsForCall)]
	fake.removeAllCVEsArgsForCall = append(fake.removeAllCVEsArgsForCall, struct {
		arg1 string
		arg2 context.Context
		arg3 *mongo.Collection
	}{arg1, arg2, arg3})
	stub := fake.RemoveAllCVEsStub
	fakeReturns := fake.removeAllCVEsReturns
	fake.recordInvocation("RemoveAllCVEs", []interface{}{arg1, arg2, arg3})
	fake.removeAllCVEsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMongoUtilsInterface) RemoveAllCVEsCallCount() int {
	fake.removeAllCVEsMutex.RLock()
	defer fake.removeAllCVEsMutex.RUnlock()
	return len(fake.removeAllCVEsArgsForCall)
}

func (fake *FakeMongoUtilsInterface) RemoveAllCVEsCalls(stub func(string, context.Context, *mongo.Collection) error) {
	fake.removeAllCVEsMutex.Lock()
	defer fake.removeAllCVEsMutex.Unlock()
	fake.RemoveAllCVEsStub = stub
}

func (fake *FakeMongoUtilsInterface) RemoveAllCVEsArgsForCall(i int) (string, context.Context, *mongo.Collection) {
	fake.removeAllCVEsMutex.RLock()
	defer fake.removeAllCVEsMutex.RUnlock()
	argsForCall := fake.removeAllCVEsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeMongoUtilsInterface) RemoveAllCVEsReturns(result1 error) {
	fake.removeAllCVEsMutex.Lock()
	defer fake.removeAllCVEsMutex.Unlock()
	fake.RemoveAllCVEsStub = nil
	fake.removeAllCVEsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoUtilsInterface) RemoveAllCVEsReturnsOnCall(i int, result1 error) {
	fake.removeAllCVEsMutex.Lock()
	defer fake.removeAllCVEsMutex.Unlock()
	fake.RemoveAllCVEsStub = nil
	if fake.removeAllCVEsReturnsOnCall == nil {
		fake.removeAllCVEsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllCVEsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeMongoUtilsInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cVEExistsMutex.RLock()
	defer fake.cVEExistsMutex.RUnlock()
	fake.createCVEMutex.RLock()
	defer fake.createCVEMutex.RUnlock()
	fake.disconnectMongoClientMutex.RLock()
	defer fake.disconnectMongoClientMutex.RUnlock()
	fake.findCVEMutex.RLock()
	defer fake.findCVEMutex.RUnlock()
	fake.getAllCVEsMutex.RLock()
	defer fake.getAllCVEsMutex.RUnlock()
	fake.getMongoClientMutex.RLock()
	defer fake.getMongoClientMutex.RUnlock()
	fake.getMongoCollectionMutex.RLock()
	defer fake.getMongoCollectionMutex.RUnlock()
	fake.getUniqueDependenciesMutex.RLock()
	defer fake.getUniqueDependenciesMutex.RUnlock()
	fake.removeAllCVEsMutex.RLock()
	defer fake.removeAllCVEsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMongoUtilsInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ utils.MongoUtilsInterface = new(FakeMongoUtilsInterface)
