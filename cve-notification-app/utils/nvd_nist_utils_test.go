package utils_test

import (
	"fmt"
	"github.com/cloudfoundry/buildpacks-ci/cve-notification-app/utils"
	"github.com/sclevine/spec"
	"github.com/sclevine/spec/report"
	assertpkg "github.com/stretchr/testify/assert"
	requirepkg "github.com/stretchr/testify/require"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

func TestNvdNistUtils(t *testing.T) {
	spec.Run(t, "NVD Nist Utils", testNvdNistUtils, spec.Report(report.Terminal{}))
}

func testNvdNistUtils(t *testing.T, context spec.G, it spec.S) {
	var (
		assert     = assertpkg.New(t)
		require    = requirepkg.New(t)
		nvdUtils   utils.NVDNistUtils
		mockServer *httptest.Server
	)

	context("Calls the GetCVEs method", func() {
		context("succeed", func() {
			it.Before(func() {
				mockServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
					if req.URL.RawQuery == "cpeMatchString=cpe:2.3:a:haxx:curl" {
						fmt.Fprint(w, `{
								   "result":{
									  "CVE_Items":[
										 {
											"cve":{
											   "CVE_data_meta":{
												  "ID":"TEST-CVE-1"
											   },
											   "description":{
												  "description_data":[
													 {
														"value":"Testing CVE1"
													 }
												  ]
											   }
											},
											"impact":{
											   "baseMetricV3":{
												  "cvssV3":{
													 "baseSeverity":"LOW"
												  }
											   }
											}
										 },
										 {
											"cve":{
											   "CVE_data_meta":{
												  "ID":"TEST-CVE-2"
											   },
											   "description":{
												  "description_data":[
													 {
														"value":"Testing CVE2"
													 }
												  ]
											   }
											},
											"impact":{
											   "baseMetricV3":{
												  "cvssV3":{
													 "baseSeverity":"CRITICAL"
												  }
											   }
											}
										 }
									  ]
								   }
								}`)
					}
				}))

				nvdUtils = utils.NVDNistUtils{
					BaseUrl: fmt.Sprintf("%s/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a", mockServer.URL),
					Client: http.Client{
						Timeout: time.Second * 5,
					},
				}
			})

			it("calls the NVD Nist API and retrieves the CVEs for the vendor/product", func() {
				cves, err := nvdUtils.GetCVEs("haxx", "curl")
				require.NoError(err)

				assert.Equal(len(cves.Result.CVEItems), 2)
			})
		})

		context("succeed when NVDNist server is down", func() {
			context("with timeout", func() {
				it.Before(func() {
					mockServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
						time.Sleep(time.Second * 2)
					}))

					nvdUtils = utils.NVDNistUtils{
						BaseUrl: fmt.Sprintf("%s/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a", mockServer.URL),
						Client: http.Client{
							Timeout: time.Second * 1,
						},
					}
				})

				it("return an empty result", func() {
					cves, err := nvdUtils.GetCVEs("haxx", "curl")
					require.NoError(err)

					assert.Equal(0, len(cves.Result.CVEItems))
				})
			})

			context("with 503 response", func() {
				it.Before(func() {
					mockServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
						w.WriteHeader(503)
					}))

					nvdUtils = utils.NVDNistUtils{
						BaseUrl: fmt.Sprintf("%s/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a", mockServer.URL),
						Client: http.Client{
							Timeout: time.Second * 5,
						},
					}
				})

				it("return an empty result", func() {
					cves, err := nvdUtils.GetCVEs("haxx", "curl")
					require.NoError(err)

					assert.Equal(0, len(cves.Result.CVEItems))
				})
			})
		})

		context("fails", func() {
			context("creating http request", func() {
				it.Before(func() {
					nvdUtils = utils.NVDNistUtils{
						BaseUrl: "bad://url",
						Client: http.Client{
							Timeout: time.Second * 5,
						},
					}
				})

				it("return an invalid URL error", func() {
					_, err := nvdUtils.GetCVEs("haxx", "curl")
					require.Error(err)

					assert.EqualError(err, "error creating NVD Nist API request\nparse \"bad://url:haxx:curl\": invalid port \":curl\" after host")
				})
			})

			context("reading http response body", func() {

				it.Before(func() {
					mockServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
						w.Header().Set("Content-Length", "1")
					}))

					nvdUtils = utils.NVDNistUtils{
						BaseUrl: fmt.Sprintf("%s/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a", mockServer.URL),
						Client: http.Client{
							Timeout: time.Second * 5,
						},
					}
				})

				it("return an invalid response body error", func() {
					_, err := nvdUtils.GetCVEs("haxx", "curl")
					require.Error(err)

					assert.EqualError(err, "error reading NVD Nist API request\nunexpected EOF")
				})
			})

			context("unmarshalling http response body", func() {

				it.Before(func() {
					mockServer = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
						fmt.Fprint(w, `{"result":{"CVE_Items":[{}`)
					}))

					nvdUtils = utils.NVDNistUtils{
						BaseUrl: fmt.Sprintf("%s/rest/json/cves/1.0?cpeMatchString=cpe:2.3:a", mockServer.URL),
						Client: http.Client{
							Timeout: time.Second * 5,
						},
					}
				})

				it("return an unmarshal error", func() {
					_, err := nvdUtils.GetCVEs("haxx", "curl")
					require.Error(err)

					assert.EqualError(err, "error unmarshaling curl NVD Nist API request\nunexpected end of JSON input")
				})
			})
		})
	})

	context("Calls the NewNVDNistUtils method", func() {
		context("succeed", func() {
			it("returns a new NVDUtils object with default url and default client", func() {
				nvdNistUtils := utils.NewNVDNistUtils("test")

				assert.Equal(nvdNistUtils.BaseUrl, "https://services.nvd.nist.gov/rest/json/cves/1.0?apiKey=test&resultsPerPage=2000&cpeMatchString=cpe:2.3:a")
				assert.Equal(nvdNistUtils.Client.Timeout, time.Minute*1)
			})
		})
	})

	context("Calls the GenerateFakeCVE method", func() {
		context("succeed", func() {
			it("returns a fake NVDNistResponse object filled with the given params", func() {
				params := []utils.FakeCVEParam{
					{
						Id:          "CVE-ID",
						Description: "Test Description",
						Severity:    "LOW",
					},
					{
						Id:          "CVE-ID-2",
						Description: "Test Description 2",
						Severity:    "HIGH",
					},
					{
						Id:          "CVE-ID-3",
						Description: "Test Description 3",
						Severity:    "CRITICAL",
					},
				}
				fakeCVE := utils.GenerateFakeCVE(params)

				assert.Equal(3, len(fakeCVE.Result.CVEItems))

				firstCveItem := fakeCVE.Result.CVEItems[0]
				assert.Equal("CVE-ID", firstCveItem.Cve.CVEDataMeta.ID)
				assert.Equal("Test Description", firstCveItem.Cve.Description.DescriptionData[0].Value)
				assert.Equal("LOW", firstCveItem.Impact.BaseMetricV3.CvssV3.BaseSeverity)

				secondCveItem := fakeCVE.Result.CVEItems[1]
				assert.Equal("CVE-ID-2", secondCveItem.Cve.CVEDataMeta.ID)
				assert.Equal("Test Description 2", secondCveItem.Cve.Description.DescriptionData[0].Value)
				assert.Equal("HIGH", secondCveItem.Impact.BaseMetricV3.CvssV3.BaseSeverity)

				thirdCveItem := fakeCVE.Result.CVEItems[2]
				assert.Equal("CVE-ID-3", thirdCveItem.Cve.CVEDataMeta.ID)
				assert.Equal("Test Description 3", thirdCveItem.Cve.Description.DescriptionData[0].Value)
				assert.Equal("CRITICAL", thirdCveItem.Impact.BaseMetricV3.CvssV3.BaseSeverity)
			})
		})
	})
}
