# encoding: utf-8
require 'rss'
require 'nokogiri'
require 'open-uri'

class RootFSCVEFeed
  attr_reader :stack
  attr_reader :stacks_dir

  def initialize(stack, stacks_dir)
    @stack = stack
    @stacks_dir = stacks_dir
  end

  def related_cves(system_name)
    raise "#{@stack} receipt not found in '#{@stacks_dir}'" unless receipt_found
    return [] unless rss

    @related_cves ||= rss.items.select do |item|
      usn_body = open(item.link).read
      html = Nokogiri::HTML(usn_body) { |c| c.options = Nokogiri::XML::ParseOptions::NOBLANKS }
      os_version_header = html.css('h5').find { |h5| h5.text.include?(system_name) }

      next unless os_version_header
      package_list = os_version_header.css('+ ul')

      packages = package_list.css('li').map do |li|
        li.css('a:first').text
      end.reject(&:empty?)

      packages.any? do |name, _version|
        find_vulnerability_in_receipt(name)
      end
    end.map(&:title)
  end

  def unrelated_cves(system_name)
    all_cves(system_name) - related_cves(system_name)
  end

  private

  def all_cves(system_name)
    raise "#{@stack} receipt not found in '#{@stacks_dir}'" unless receipt_found
    rss.items.map(&:title)
  end

  def feed_uri
    'https://ubuntu.com/security/notices/rss.xml'
  end

  def rss
    @rss ||= RSS::Parser.parse(open(feed_uri), false)
  end

  def receipt_found
    case @stack
    when 'cflinuxfs3'
      File.exist? "#{@stacks_dir}/receipt.#{@stack}.x86_64"
    when 'cflinuxfs4'
      File.exist? "#{@stacks_dir}/receipt.#{@stack}.x86_64"
    else
      raise "Unsupported stack #{@stack}"
    end
  end

  def find_vulnerability_in_receipt(name)
    regex = "\\s#{name}(:amd64)*\\s"
    Dir.chdir(@stacks_dir) do
      if name != ""
        case @stack
        when 'cflinuxfs3'
          !open("receipt.#{@stack}.x86_64", 'r').grep(/#{regex}/).empty?
        when 'cflinuxfs4'
          !open("receipt.#{@stack}.x86_64", 'r').grep(/#{regex}/).empty?
        else
          raise "Unsupported stack #{@stack}"
        end
      end
    end
  end
end
